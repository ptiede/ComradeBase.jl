<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · ComradeBase.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://ptiede.github.io/ComradeBase.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>ComradeBase.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ptiede/ComradeBase.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ComradeBase"><a class="docs-heading-anchor" href="#ComradeBase">ComradeBase</a><a id="ComradeBase-1"></a><a class="docs-heading-anchor-permalink" href="#ComradeBase" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/ptiede/ComradeBase.jl">ComradeBase</a>.</p><ul><li><a href="#ComradeBase.AbstractModel"><code>ComradeBase.AbstractModel</code></a></li><li><a href="#ComradeBase.AbstractPolarizedModel"><code>ComradeBase.AbstractPolarizedModel</code></a></li><li><a href="#ComradeBase.CirBasis"><code>ComradeBase.CirBasis</code></a></li><li><a href="#ComradeBase.CoherencyMatrix"><code>ComradeBase.CoherencyMatrix</code></a></li><li><a href="#ComradeBase.CoherencyMatrix"><code>ComradeBase.CoherencyMatrix</code></a></li><li><a href="#ComradeBase.CoherencyMatrix-Tuple{Number, Number, Number, Number, Tuple{PolBasis, PolBasis}}"><code>ComradeBase.CoherencyMatrix</code></a></li><li><a href="#ComradeBase.CoherencyMatrix-Tuple{Number, Number, Number, Number, PolBasis}"><code>ComradeBase.CoherencyMatrix</code></a></li><li><a href="#ComradeBase.CoherencyMatrix-Tuple{Number, Number, Number, Number, PolBasis, PolBasis}"><code>ComradeBase.CoherencyMatrix</code></a></li><li><a href="#ComradeBase.DensityAnalytic"><code>ComradeBase.DensityAnalytic</code></a></li><li><a href="#ComradeBase.ElectricFieldBasis"><code>ComradeBase.ElectricFieldBasis</code></a></li><li><a href="#ComradeBase.GriddedKeys"><code>ComradeBase.GriddedKeys</code></a></li><li><a href="#ComradeBase.GriddedKeys-Union{Tuple{Tuple}, Tuple{Na}, Tuple{Tuple, Any}} where Na"><code>ComradeBase.GriddedKeys</code></a></li><li><a href="#ComradeBase.GriddedKeys-Union{Tuple{NamedTuple{N}}, Tuple{N}, Tuple{NamedTuple{N}, Any}} where N"><code>ComradeBase.GriddedKeys</code></a></li><li><a href="#ComradeBase.IntensityMap-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, ComradeBase.AbstractDims}} where {T, N}"><code>ComradeBase.IntensityMap</code></a></li><li><a href="#ComradeBase.IsAnalytic"><code>ComradeBase.IsAnalytic</code></a></li><li><a href="#ComradeBase.IsPrimitive"><code>ComradeBase.IsPrimitive</code></a></li><li><a href="#ComradeBase.LPol"><code>ComradeBase.LPol</code></a></li><li><a href="#ComradeBase.LinBasis"><code>ComradeBase.LinBasis</code></a></li><li><a href="#ComradeBase.NotAnalytic"><code>ComradeBase.NotAnalytic</code></a></li><li><a href="#ComradeBase.NotPrimitive"><code>ComradeBase.NotPrimitive</code></a></li><li><a href="#ComradeBase.PolBasis"><code>ComradeBase.PolBasis</code></a></li><li><a href="#ComradeBase.PrimitiveTrait"><code>ComradeBase.PrimitiveTrait</code></a></li><li><a href="#ComradeBase.RPol"><code>ComradeBase.RPol</code></a></li><li><a href="#ComradeBase.SingleStokes"><code>ComradeBase.SingleStokes</code></a></li><li><a href="#ComradeBase.StokesIntensityMap"><code>ComradeBase.StokesIntensityMap</code></a></li><li><a href="#ComradeBase.StokesParams"><code>ComradeBase.StokesParams</code></a></li><li><a href="#ComradeBase.XPol"><code>ComradeBase.XPol</code></a></li><li><a href="#ComradeBase.YPol"><code>ComradeBase.YPol</code></a></li><li><a href="#ComradeBase.axisdims-Tuple{AxisKeys.KeyedArray{T, N, &lt;:Any, G} where {T, N, G&lt;:ComradeBase.AbstractDims}}"><code>ComradeBase.axisdims</code></a></li><li><a href="#ComradeBase.basis_components"><code>ComradeBase.basis_components</code></a></li><li><a href="#ComradeBase.basis_transform"><code>ComradeBase.basis_transform</code></a></li><li><a href="#ComradeBase.centroid-Tuple{IntensityMapTypes}"><code>ComradeBase.centroid</code></a></li><li><a href="#ComradeBase.dims-Tuple{ComradeBase.AbstractDims}"><code>ComradeBase.dims</code></a></li><li><a href="#ComradeBase.evpa-Tuple{StokesParams}"><code>ComradeBase.evpa</code></a></li><li><a href="#ComradeBase.fieldofview-Tuple{IntensityMapTypes}"><code>ComradeBase.fieldofview</code></a></li><li><a href="#ComradeBase.flux-Union{Tuple{IntensityMapTypes{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><code>ComradeBase.flux</code></a></li><li><a href="#ComradeBase.header-Tuple{AxisKeys.KeyedArray{T, N, &lt;:Any, G} where {T, N, G&lt;:ComradeBase.AbstractDims}}"><code>ComradeBase.header</code></a></li><li><a href="#ComradeBase.header-Tuple{ComradeBase.AbstractDims}"><code>ComradeBase.header</code></a></li><li><a href="#ComradeBase.imagegrid-Tuple{IntensityMapTypes}"><code>ComradeBase.imagegrid</code></a></li><li><a href="#ComradeBase.imagepixels-Tuple{IntensityMapTypes}"><code>ComradeBase.imagepixels</code></a></li><li><a href="#ComradeBase.imanalytic-Tuple{Type{&lt;:ComradeBase.AbstractModel}}"><code>ComradeBase.imanalytic</code></a></li><li><a href="#ComradeBase.innerprod"><code>ComradeBase.innerprod</code></a></li><li><a href="#ComradeBase.intensity_point"><code>ComradeBase.intensity_point</code></a></li><li><a href="#ComradeBase.intensitymap"><code>ComradeBase.intensitymap</code></a></li><li><a href="#ComradeBase.intensitymap"><code>ComradeBase.intensitymap</code></a></li><li><a href="#ComradeBase.intensitymap-Union{Tuple{M}, Tuple{M, ComradeBase.AbstractDims}} where M&lt;:ComradeBase.AbstractModel"><code>ComradeBase.intensitymap</code></a></li><li><a href="#ComradeBase.intensitymap!-Union{Tuple{M}, Tuple{IntensityMapTypes, M}} where M"><code>ComradeBase.intensitymap!</code></a></li><li><a href="#ComradeBase.intensitymap!"><code>ComradeBase.intensitymap!</code></a></li><li><a href="#ComradeBase.ispolarized-Tuple{Type{&lt;:ComradeBase.AbstractModel}}"><code>ComradeBase.ispolarized</code></a></li><li><a href="#ComradeBase.isprimitive"><code>ComradeBase.isprimitive</code></a></li><li><a href="#ComradeBase.linearpol-Tuple{StokesParams}"><code>ComradeBase.linearpol</code></a></li><li><a href="#ComradeBase.m̆-Union{Tuple{StokesParams{T}}, Tuple{T}} where T"><code>ComradeBase.m̆</code></a></li><li><a href="#ComradeBase.named_dims-Union{Tuple{ComradeBase.AbstractDims{N}}, Tuple{N}} where N"><code>ComradeBase.named_dims</code></a></li><li><a href="#ComradeBase.phasecenter-Tuple{IntensityMapTypes}"><code>ComradeBase.phasecenter</code></a></li><li><a href="#ComradeBase.pixelsizes-Tuple{IntensityMapTypes}"><code>ComradeBase.pixelsizes</code></a></li><li><a href="#ComradeBase.radialextent"><code>ComradeBase.radialextent</code></a></li><li><a href="#ComradeBase.second_moment-Union{Tuple{IntensityMapTypes{T, 2}}, Tuple{T}} where T"><code>ComradeBase.second_moment</code></a></li><li><a href="#ComradeBase.second_moment-Union{Tuple{IntensityMapTypes{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><code>ComradeBase.second_moment</code></a></li><li><a href="#ComradeBase.stokes-Tuple{ComradeBase.AbstractPolarizedModel, Symbol}"><code>ComradeBase.stokes</code></a></li><li><a href="#ComradeBase.visanalytic-Tuple{Type{&lt;:ComradeBase.AbstractModel}}"><code>ComradeBase.visanalytic</code></a></li><li><a href="#ComradeBase.visibility_point"><code>ComradeBase.visibility_point</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.AbstractModel" href="#ComradeBase.AbstractModel"><code>ComradeBase.AbstractModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractModel</code></pre><p>The Comrade abstract model type. To instantiate your own model type you should subtybe from this model. Additionally you need to implement the following methods to satify the interface:</p><p><strong>Mandatory Methods</strong></p><ul><li><a href="#ComradeBase.isprimitive"><code>isprimitive</code></a>: defines whether a model is standalone or is defined in terms of other models.  is the model is primitive then this should return <code>IsPrimitive()</code> otherwise it returns  <code>NotPrimitive()</code></li><li><a href="#ComradeBase.visanalytic-Tuple{Type{&lt;:ComradeBase.AbstractModel}}"><code>visanalytic</code></a>: defines whether the model visibilities can be computed analytically. If yes  then this should return <code>IsAnalytic()</code> and the user <em>must</em> to define <code>visibility_point</code>.  If not analytic then <code>visanalytic</code> should return <code>NotAnalytic()</code>.</li><li><a href="#ComradeBase.imanalytic-Tuple{Type{&lt;:ComradeBase.AbstractModel}}"><code>imanalytic</code></a>: defines whether the model intensities can be computed pointwise. If yes</li></ul><p>then this should return <code>IsAnalytic()</code> and the user <em>must</em> to define <code>intensity_point</code>. If not analytic then <code>imanalytic</code> should return <code>NotAnalytic()</code>.</p><ul><li><a href="#ComradeBase.radialextent"><code>radialextent</code></a>: Provides a estimate of the radial extent of the model in the image domain.  This is used for estimating the size of the image, and for plotting.</li><li><a href="#ComradeBase.flux-Union{Tuple{IntensityMapTypes{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><code>flux</code></a>: Returns the total flux of the model.</li></ul><p><strong>Optional Methods:</strong></p><ul><li><a href="#ComradeBase.intensity_point"><code>intensity_point</code></a>: Defines how to compute model intensities pointwise. Note this is must be defined if <code>imanalytic(::Type{YourModel})==IsAnalytic()</code>.</li><li><a href="#ComradeBase.visibility_point"><code>visibility_point</code></a>: Defines how to compute model visibilties pointwise. Note this is   must be defined if <code>visanalytic(::Type{YourModel})==IsAnalytic()</code>.</li><li><a href="@ref"><code>_visibilities</code></a>: Vectorized version of <code>visibility_point</code> if you can gain additional speed</li><li><a href="#ComradeBase.intensitymap"><code>intensitymap</code></a>: Computes the whole image of the model</li><li><a href="#ComradeBase.intensitymap!"><code>intensitymap!</code></a>: Inplace version of <code>intensitymap</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/interface.jl#L2-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.AbstractPolarizedModel" href="#ComradeBase.AbstractPolarizedModel"><code>ComradeBase.AbstractPolarizedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractPolarizedModel &lt;: ComradeBase.AbstractModel</code></pre><p>Type the classifies a model as being intrinsically polarized. This means that any call to visibility must return a <code>StokesParams</code> to denote the full stokes polarization of the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/interface.jl#L38-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.CirBasis" href="#ComradeBase.CirBasis"><code>ComradeBase.CirBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CirBasis &lt;: PolBasis</code></pre><p>Measurement uses the circular polarization basis, which is typically used for circular feed interferometers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/polarizedtypes.jl#L57-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.CoherencyMatrix" href="#ComradeBase.CoherencyMatrix"><code>ComradeBase.CoherencyMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CoherencyMatrix(s::StokesParams, basis1::PolBasis)
CoherencyMatrix(s::StokesParams, basis1::PolBasis, basis2::PolBasis)
CoherencyMatrix(s::StokesParams, basis1::PolBasis, basis2::PolBasis, refbasis=CirBasis())</code></pre><p>Constructs the coherency matrix from the set of stokes parameters <code>s</code>. This is specialized on <code>basis1</code> and <code>basis2</code> which form the tensor product basis <code>|basis1&gt;&lt;basis2|</code>, or if a single basis is given then by <code>|basis&gt;&lt;basis|</code>.</p><p>For example</p><pre><code class="language-julia hljs">CoherencyMatrix(s, CircBasis())</code></pre><p>will give the coherency matrix</p><p>|I+V   Q+iU|    |Q-iU  I-V |</p><p>while</p><pre><code class="language-julia hljs">CoherencyMatrix(s, LinBasis())</code></pre><p>will give     |I+Q   U+iV|     |U-iV  I-Q |</p><p><strong>Notes</strong></p><p>Internally this function first converts to a reference basis and then the final basis. You can select the reference basis used with the optional argument refbasis. By default we use the circular basis as our reference. Note that this is only important for mixed bases, e.g., if <code>basis1</code> and <code>basis2</code> are different. If <code>basis1==basis2</code> then the reference basis is never used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/polarizedtypes.jl#L347-L380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.CoherencyMatrix" href="#ComradeBase.CoherencyMatrix"><code>ComradeBase.CoherencyMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CoherencyMatrix{B1, B2, T} &lt;: StaticArraysCore.FieldMatrix{2, 2, T}</code></pre><p>Coherency matrix for a single baseline with bases <code>B1</code> and <code>B2</code>. The two bases correspond to the type of feeds used for each telescope and should be subtypes of <code>PolBasis</code>. To see which bases are implemented type <code>subtypes(Rimes.PolBasis)</code> in the REPL.</p><p>For a circular basis the layout of the coherency matrix is</p><pre><code class="nohighlight hljs">RR* RL*
LR* RR*</code></pre><p>which can be constructed using</p><pre><code class="language-julia-repl hljs">c = CoherencyMatrix(RR, LR, RL, LL, CirBasis())</code></pre><p>For a linear basis the layout of the coherency matrix is</p><pre><code class="nohighlight hljs">XX* XY*
YX* YY*</code></pre><p>which can be constructed using</p><pre><code class="language-julia-repl hljs">c = CoherencyMatrix(XX, YX, XY, YY, CirBasis())</code></pre><p>For a mixed (e.g., circular and linear basis) the layout of the coherency matrix is</p><pre><code class="nohighlight hljs">RX* RY*
LX* LY*</code></pre><p>or e.g., linear and circular the layout of the coherency matrix is</p><pre><code class="nohighlight hljs">XR* XL*
YR* YL*</code></pre><p>These coherency matrices can be constructed using:</p><pre><code class="language-julia-repl hljs"># Circular and linear feeds i.e., |R&gt;&lt;X|
c = CoherencyMatrix(RX, LX, RY, LY, LinBasis(), CirBasis())
# Linear and circular feeds i.e., |X&gt;&lt;R|
c = CoherencyMatrix(XR, YR, XL, YL, LinBasis(), CirBasis())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/polarizedtypes.jl#L199-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.CoherencyMatrix-Tuple{Number, Number, Number, Number, PolBasis, PolBasis}" href="#ComradeBase.CoherencyMatrix-Tuple{Number, Number, Number, Number, PolBasis, PolBasis}"><code>ComradeBase.CoherencyMatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CoherencyMatrix(e11, e21, e12, e22, basis1::PolBasis basis2::PolBasis)</code></pre><p>Constructs the coherency matrix with components    e11 e12    e21 e22 relative to the tensor product basis, <code>basis</code> given by <code>|basis1&gt;&lt;basis2|</code>.</p><p>For instance</p><pre><code class="language-julia hljs">c = Coherency(1.0, 0.0, 0.0, 1.0, CirBasis(), LinBasis())</code></pre><p>elements correspond to     RX* RY*     LX* LY*</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/polarizedtypes.jl#L316-L332">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.CoherencyMatrix-Tuple{Number, Number, Number, Number, PolBasis}" href="#ComradeBase.CoherencyMatrix-Tuple{Number, Number, Number, Number, PolBasis}"><code>ComradeBase.CoherencyMatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CoherencyMatrix(e11, e21, e12, e22, basis::PolBasis)</code></pre><p>Constructs the coherency matrix with components    e11 e12    e21 e22 relative to the tensor product basis, <code>basis</code> given by <code>|basis&gt;&lt;basis|</code>.</p><p>For instance</p><pre><code class="language-julia hljs">c = Coherency(1.0, 0.0, 0.0, 1.0, CirBasis())</code></pre><p>elements correspond to     RR* RL*     LR* LL*</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/polarizedtypes.jl#L295-L311">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.CoherencyMatrix-Tuple{Number, Number, Number, Number, Tuple{PolBasis, PolBasis}}" href="#ComradeBase.CoherencyMatrix-Tuple{Number, Number, Number, Number, Tuple{PolBasis, PolBasis}}"><code>ComradeBase.CoherencyMatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CoherencyMatrix(e11, e21, e12, e22, basis::NTuple{2, PolBasis})</code></pre><p>Constructs the coherency matrix with components    e11 e12    e21 e22 relative to the tensor product basis, <code>|basis[1]&gt;&lt;basis[2]|</code>. Note that basis[1] and basis[2] could be different.</p><p>For instance</p><pre><code class="language-julia hljs">c = Coherency(1.0, 0.0, 0.0, 1.0, CirBasis(), LinBasis())</code></pre><p>elements correspond to     RX* RY*     LX* LY*</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/polarizedtypes.jl#L273-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.DensityAnalytic" href="#ComradeBase.DensityAnalytic"><code>ComradeBase.DensityAnalytic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DensityAnalytic</code></pre><p>Internal type for specifying the nature of the model functions. Whether they can be easily evaluated pointwise analytic. This is an internal type that may change.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/interface.jl#L116-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.ElectricFieldBasis" href="#ComradeBase.ElectricFieldBasis"><code>ComradeBase.ElectricFieldBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type ElectricFieldBasis</code></pre><p>An abstract type whose subtypes denote a specific electric field basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/polarizedtypes.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.GriddedKeys" href="#ComradeBase.GriddedKeys"><code>ComradeBase.GriddedKeys</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GriddedKeys{N, G, Hd, T} &lt;: ComradeBase.AbstractDims{N, T}</code></pre><p>This struct holds the dimensions that the EHT expect. The first type parameter <code>N</code> defines the names of each dimension. These names are usually one of     - (:X, :Y, :T, :F)     - (:X, :Y, :F, :T)     - (:X, :Y) # spatial only where <code>:X,:Y</code> are the RA and DEC spatial dimensions respectively, <code>:T</code> is the the time direction and <code>:F</code> is the frequency direction.</p><p><strong>Fieldnames</strong></p><ul><li><p><code>dims</code></p></li><li><p><code>header</code></p></li></ul><p><strong>Notes</strong></p><p>Warning it is rare you need to access this constructor directly. Instead use the direct <a href="#ComradeBase.IntensityMap-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, ComradeBase.AbstractDims}} where {T, N}"><code>IntensityMap</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/images/keyed_image.jl#L9-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.GriddedKeys-Union{Tuple{NamedTuple{N}}, Tuple{N}, Tuple{NamedTuple{N}, Any}} where N" href="#ComradeBase.GriddedKeys-Union{Tuple{NamedTuple{N}}, Tuple{N}, Tuple{NamedTuple{N}, Any}} where N"><code>ComradeBase.GriddedKeys</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GriddedKeys(dims::NamedTuple{Na}, header=nothing)</code></pre><p>Builds the EHT image dimensions using the names <code>Na</code> and dimensions are the values of <code>dims</code>. You can also optionally has a header that stores additional information from e.g., a FITS header. The type parameter <code>Na</code> defines the names of each dimension. These names are usually one of     - (:X, :Y, :T, :F)     - (:X, :Y, :F, :T)     - (:X, :Y) # spatial only where <code>:X,:Y</code> are the RA and DEC spatial dimensions respectively, <code>:T</code> is the the time direction and <code>:F</code> is the frequency direction.</p><p><strong>Notes</strong></p><p>Instead use the direct <a href="#ComradeBase.IntensityMap-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, ComradeBase.AbstractDims}} where {T, N}"><code>IntensityMap</code></a> function.</p><pre><code class="language-julia hljs">dims = GriddedKeys((X=-5.0:0.1:5.0, Y=-4.0:0.1:4.0, T=[1.0, 1.5, 1.75], F=[230, 345]))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/images/keyed_image.jl#L110-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.GriddedKeys-Union{Tuple{Tuple}, Tuple{Na}, Tuple{Tuple, Any}} where Na" href="#ComradeBase.GriddedKeys-Union{Tuple{Tuple}, Tuple{Na}, Tuple{Tuple, Any}} where Na"><code>ComradeBase.GriddedKeys</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GriddedKeys{Na}(dims::Tuple, header=nothing) where {Na}</code></pre><p>Builds the EHT image dimensions using the names <code>Na</code> and dimensions <code>dims</code>. You can also optionally has a header that stores additional information from e.g., a FITS header. The type parameter <code>Na</code> defines the names of each dimension. These names are usually one of     - (:X, :Y, :T, :F)     - (:X, :Y, :F, :T)     - (:X, :Y) # spatial only where <code>:X,:Y</code> are the RA and DEC spatial dimensions respectively, <code>:T</code> is the the time direction and <code>:F</code> is the frequency direction.</p><p><strong>Notes</strong></p><p>Instead use the direct <a href="#ComradeBase.IntensityMap-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, ComradeBase.AbstractDims}} where {T, N}"><code>IntensityMap</code></a> function.</p><pre><code class="language-julia hljs">dims = GriddedKeys{(:X, :Y, :T, :F)}((-5.0:0.1:5.0, -4.0:0.1:4.0, [1.0, 1.5, 1.75], [230, 345]))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/images/keyed_image.jl#L86-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.IntensityMap-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, ComradeBase.AbstractDims}} where {T, N}" href="#ComradeBase.IntensityMap-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, ComradeBase.AbstractDims}} where {T, N}"><code>ComradeBase.IntensityMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">IntensityMap(data::AbstractArray, dims::NamedTuple)
IntensityMap(data::AbstractArray, grid::AbstractDims)</code></pre><p>Constructs an intensitymap using the image dimensions given by <code>dims</code>. This returns a <code>KeyedArray</code> with keys given by an <code>ImageDimensions</code> object.</p><pre><code class="language-julia hljs">dims = (X=range(-10.0, 10.0, length=100), Y = range(-10.0, 10.0, length=100),
        T = [0.1, 0.2, 0.5, 0.9, 1.0], F = [230e9, 345e9]
        )
imgk = IntensityMap(rand(100,100,5,1), dims)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/images/keyed_image.jl#L230-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.IsAnalytic" href="#ComradeBase.IsAnalytic"><code>ComradeBase.IsAnalytic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct IsAnalytic &lt;: ComradeBase.DensityAnalytic</code></pre><p>Defines a trait that a states that a model is analytic. This is usually used with an abstract model where we use it to specify whether a model has a analytic fourier transform and/or image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/interface.jl#L125-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.IsPrimitive" href="#ComradeBase.IsPrimitive"><code>ComradeBase.IsPrimitive</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct IsPrimitive</code></pre><p>Trait for primitive model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/interface.jl#L80-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.LPol" href="#ComradeBase.LPol"><code>ComradeBase.LPol</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LPol &lt;: ComradeBase.ElectricFieldBasis</code></pre><p>The left circular electric field basis, i.e. a left-handed circular feed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/polarizedtypes.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.LinBasis" href="#ComradeBase.LinBasis"><code>ComradeBase.LinBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinBasis &lt;: PolBasis</code></pre><p>Measurement uses the linear polarization basis, which is typically used for linear feed interferometers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/polarizedtypes.jl#L65-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.NotAnalytic" href="#ComradeBase.NotAnalytic"><code>ComradeBase.NotAnalytic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NotAnalytic &lt;: ComradeBase.DensityAnalytic</code></pre><p>Defines a trait that a states that a model is analytic. This is usually used with an abstract model where we use it to specify whether a model has does not have a easy analytic fourier transform and/or intensity function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/interface.jl#L135-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.NotPrimitive" href="#ComradeBase.NotPrimitive"><code>ComradeBase.NotPrimitive</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NotPrimitive</code></pre><p>Trait for not-primitive model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/interface.jl#L85-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.PolBasis" href="#ComradeBase.PolBasis"><code>ComradeBase.PolBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct PolBasis{B1&lt;:Union{Missing, ComradeBase.ElectricFieldBasis}, B2&lt;:Union{Missing, ComradeBase.ElectricFieldBasis}}</code></pre><p>Denotes a general polarization basis, with basis vectors (B1,B2) which are typically <code>&lt;: Union{ElectricFieldBasis, Missing}</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/polarizedtypes.jl#L48-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.PrimitiveTrait" href="#ComradeBase.PrimitiveTrait"><code>ComradeBase.PrimitiveTrait</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type PrimitiveTrait</code></pre><p>This trait specifies whether the model is a <em>primitive</em></p><p><strong>Notes</strong></p><p>This will likely turn into a trait in the future so people can inject their models into Comrade more easily.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/interface.jl#L69-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.RPol" href="#ComradeBase.RPol"><code>ComradeBase.RPol</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RPol &lt;: ComradeBase.ElectricFieldBasis</code></pre><p>The right circular electric field basis, i.e. a right-handed circular feed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/polarizedtypes.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.SingleStokes" href="#ComradeBase.SingleStokes"><code>ComradeBase.SingleStokes</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SingleStokes{M, S} &lt;: ComradeBase.AbstractModel</code></pre><p>Helper function that converts a model from something that compute polarized images to just a single stokes parameter. This is useful if you just want to fit a single stokes parameter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/polarizedtypes.jl#L475-L480">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.StokesIntensityMap" href="#ComradeBase.StokesIntensityMap"><code>ComradeBase.StokesIntensityMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct StokesIntensityMap{T, N, SI, SQ, SU, SV}</code></pre><p>General struct that holds intensity maps for each stokes parameter. Each image <code>I, Q, U, V</code> must share the same axis dimensions. This type also obeys much of the usual array interface in Julia. The following methods have been implemented:</p><ul><li>size</li><li>eltype (returns StokesParams)</li><li>ndims</li><li>getindex</li><li>setindex!</li><li>pixelsizes</li><li>fieldofview</li><li>imagepixels</li><li>imagegrid</li><li>stokes</li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This may eventually be phased out for <code>IntensityMaps</code> whose base types are <code>StokesParams</code>, but currently we use this for speed reasons with Zygote.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/images/stokes_image.jl#L4-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.StokesParams" href="#ComradeBase.StokesParams"><code>ComradeBase.StokesParams</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct StokesParams{T} &lt;: StaticArraysCore.FieldVector{4, T}</code></pre><p>Static vector that holds the stokes parameters of a polarized complex visibility</p><p>To convert between a <code>StokesParams</code> and <code>CoherencyMatrix</code> use the <code>convert</code> function</p><pre><code class="language-julia hljs">convert(::CoherencyMatrix, StokesVector(1.0, 0.1, 0.1, 0.4))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/polarizedtypes.jl#L175-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.XPol" href="#ComradeBase.XPol"><code>ComradeBase.XPol</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct XPol &lt;: ComradeBase.ElectricFieldBasis</code></pre><p>The horizontal or X electric feed basis, i.e. the horizontal linear feed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/polarizedtypes.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.YPol" href="#ComradeBase.YPol"><code>ComradeBase.YPol</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct YPol &lt;: ComradeBase.ElectricFieldBasis</code></pre><p>The vertical or Y electric feed basis, i.e. the vertical linear feed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/polarizedtypes.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.axisdims-Tuple{AxisKeys.KeyedArray{T, N, &lt;:Any, G} where {T, N, G&lt;:ComradeBase.AbstractDims}}" href="#ComradeBase.axisdims-Tuple{AxisKeys.KeyedArray{T, N, &lt;:Any, G} where {T, N, G&lt;:ComradeBase.AbstractDims}}"><code>ComradeBase.axisdims</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">axisdims(img::IntensityMap)</code></pre><p>Returns the keys of the <code>IntensityMap</code> as the actual internal <code>AbstractDims</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/images/keyed_image.jl#L171-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.basis_components" href="#ComradeBase.basis_components"><code>ComradeBase.basis_components</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basis_components([T=Float64,], e::ElectricFieldBasis, b::PolBasis)</code></pre><p>Returns a static vector that contains the components of the electric field basis vector <code>e</code> in terms of the polarization basis <code>b</code>. The first argument is optionally the eltype of the static vector.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; basis_components(Float64, R(), PolBasis{XPol,Y}())
2-element StaticArraysCore.SVector{2, ComplexF64} with indices SOneTo(2):
 0.7071067811865475 + 0.0im
                0.0 - 0.7071067811865475im

julia&gt; basis_components(R(), PolBasis{XPol,Y}())
2-element StaticArraysCore.SVector{2, ComplexF64} with indices SOneTo(2):
 0.7071067811865475 + 0.0im
                0.0 - 0.7071067811865475im


julia&gt; basis_components(Float64, X(), PolBasis{XPol,Y}())
2-element StaticArraysCore.SVector{2, ComplexF64} with indices SOneTo(2):
 1.0 + 0.0im
 0.0 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/polarizedtypes.jl#L73-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.basis_transform" href="#ComradeBase.basis_transform"><code>ComradeBase.basis_transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basis_transform([T=Float64,], b1::PolBasis, b2::PolBasis)
basis_transform([T=Float64,], b1::PolBasis=&gt;b2::PolBasis)</code></pre><p>Produces the transformation matrix that transforms the vector components from basis <code>b1</code> to basis <code>b2</code>. This means that if for example <code>E</code> is the circular basis then <code>basis_transform(CirBasis=&gt;LinBasis)E</code> is in the linear basis. In other words the <strong>columns</strong> of the transformation matrix are the coordinate vectors of the new basis vectors in the old basis.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; basis_transform(CirBasis()=&gt;LinBasis())
2×2 StaticArraysCore.SMatrix{2, 2, ComplexF64, 4} with indices SOneTo(2)×SOneTo(2):
 0.707107-0.0im       0.707107-0.0im
      0.0-0.707107im       0.0+0.707107im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/polarizedtypes.jl#L147-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.centroid-Tuple{IntensityMapTypes}" href="#ComradeBase.centroid-Tuple{IntensityMapTypes}"><code>ComradeBase.centroid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centroid(im::AbstractIntensityMap)</code></pre><p>Computes the image centroid aka the center of light of the image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/images/methods.jl#L97-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.dims-Tuple{ComradeBase.AbstractDims}" href="#ComradeBase.dims-Tuple{ComradeBase.AbstractDims}"><code>ComradeBase.dims</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dims(g::AbstractDims)</code></pre><p>Returns a tuple containing the dimensions of <code>g</code>. For a named version see <a href="#ComradeBase.named_dims-Union{Tuple{ComradeBase.AbstractDims{N}}, Tuple{N}} where N"><code>named_dims</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/images/keyed_image.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.evpa-Tuple{StokesParams}" href="#ComradeBase.evpa-Tuple{StokesParams}"><code>ComradeBase.evpa</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evpa(m)
</code></pre><p>Compute the evpa of a stokes vector or cohereny matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/polarizedtypes.jl#L466-L469">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.fieldofview-Tuple{IntensityMapTypes}" href="#ComradeBase.fieldofview-Tuple{IntensityMapTypes}"><code>ComradeBase.fieldofview</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fieldofview(img::IntensityMap)
fieldofview(img::IntensityMapTypes)</code></pre><p>Returns a named tuple with the field of view of the image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/images/methods.jl#L47-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.flux-Union{Tuple{IntensityMapTypes{T, N}}, Tuple{N}, Tuple{T}} where {T, N}" href="#ComradeBase.flux-Union{Tuple{IntensityMapTypes{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><code>ComradeBase.flux</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux(im::IntensityMap)
flux(img::StokesIntensityMap)</code></pre><p>Computes the flux of a intensity map</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/images/methods.jl#L80-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.header-Tuple{AxisKeys.KeyedArray{T, N, &lt;:Any, G} where {T, N, G&lt;:ComradeBase.AbstractDims}}" href="#ComradeBase.header-Tuple{AxisKeys.KeyedArray{T, N, &lt;:Any, G} where {T, N, G&lt;:ComradeBase.AbstractDims}}"><code>ComradeBase.header</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">header(img::IntensityMap)</code></pre><p>Retrieves the header of an IntensityMap</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/images/keyed_image.jl#L180-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.header-Tuple{ComradeBase.AbstractDims}" href="#ComradeBase.header-Tuple{ComradeBase.AbstractDims}"><code>ComradeBase.header</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">header(g::AbstractDims)</code></pre><p>Returns the headerinformation of the dimensions <code>g</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/images/keyed_image.jl#L45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.imagegrid-Tuple{IntensityMapTypes}" href="#ComradeBase.imagegrid-Tuple{IntensityMapTypes}"><code>ComradeBase.imagegrid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">imagegrid(k::IntensityMap)</code></pre><p>Returns the grid the <code>IntensityMap</code> is defined as. Note that this is unallocating since it lazily computes the grid. The grid is an example of a KeyedArray and works similarly. This is useful for broadcasting a model across an abritrary grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/images/methods.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.imagepixels-Tuple{IntensityMapTypes}" href="#ComradeBase.imagepixels-Tuple{IntensityMapTypes}"><code>ComradeBase.imagepixels</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">imagepixels(img::IntensityMap)
imagepixels(img::IntensityMapTypes)</code></pre><p>Returns a abstract spatial dimension with the image pixels locations <code>X</code> and <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/images/methods.jl#L25-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.imanalytic-Tuple{Type{&lt;:ComradeBase.AbstractModel}}" href="#ComradeBase.imanalytic-Tuple{Type{&lt;:ComradeBase.AbstractModel}}"><code>ComradeBase.imanalytic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">imanalytic(::Type{&lt;:AbstractModel})</code></pre><p>Determines whether the model is pointwise analytic in the image domain, i.e. we can evaluate its intensity at an arbritrary point.</p><p>If <code>IsAnalytic()</code> then it will try to call <code>intensity_point</code> to calculate the intensity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/interface.jl#L157-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.innerprod" href="#ComradeBase.innerprod"><code>ComradeBase.innerprod</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">innerprod(::Type{T}, XPol(), YPol())</code></pre><p>Computes the complex inner product of two elements of a complex Hilbert space <code>X</code> and <code>Y</code> where base element of the output is T.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/polarizedtypes.jl#L102-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.intensity_point" href="#ComradeBase.intensity_point"><code>ComradeBase.intensity_point</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">intensity_point(model::AbstractModel, p)</code></pre><p>Function that computes the pointwise intensity if the model has the trait in the image domain <code>IsAnalytic()</code>. Otherwise it will use construct the image in visibility space and invert it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/interface.jl#L188-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.intensitymap" href="#ComradeBase.intensitymap"><code>ComradeBase.intensitymap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">intensitymap(s, fovx, fovy, nx, ny, x0=0.0, y0=0.0)</code></pre><p>Creates a <em>spatial only</em> IntensityMap intensity map whose pixels in the <code>x</code>, <code>y</code> direction are such that the image has a field of view <code>fovx</code>, <code>fovy</code>, with the number of pixels <code>nx</code>, <code>ny</code>, and the origin or phase center of the image is at <code>x0</code>, <code>y0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/images/images.jl#L36-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.intensitymap" href="#ComradeBase.intensitymap"><code>ComradeBase.intensitymap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">intensitymap(model::AbstractModel, args...)</code></pre><p>Computes the intensity map of model. For the inplace version see <a href="#ComradeBase.intensitymap!"><code>intensitymap!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/interface.jl#L206-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.intensitymap!" href="#ComradeBase.intensitymap!"><code>ComradeBase.intensitymap!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">intensitymap!(buffer::AbstractDimArray, model::AbstractModel)</code></pre><p>Computes the intensity map of <code>model</code> by modifying the <code>buffer</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/interface.jl#L198-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.intensitymap!-Union{Tuple{M}, Tuple{IntensityMapTypes, M}} where M" href="#ComradeBase.intensitymap!-Union{Tuple{M}, Tuple{IntensityMapTypes, M}} where M"><code>ComradeBase.intensitymap!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intensitymap!(img::AbstractIntensityMap, mode;, executor = SequentialEx())</code></pre><p>Computes the intensity map or <em>image</em> of the <code>model</code>. This updates the <code>IntensityMap</code> object <code>img</code>.</p><p>Optionally the user can specify the <code>executor</code> that uses <code>FLoops.jl</code> to specify how the loop is done. By default we use the <code>SequentialEx</code> which uses a single-core to construct the image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/images/images.jl#L49-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.intensitymap-Union{Tuple{M}, Tuple{M, ComradeBase.AbstractDims}} where M&lt;:ComradeBase.AbstractModel" href="#ComradeBase.intensitymap-Union{Tuple{M}, Tuple{M, ComradeBase.AbstractDims}} where M&lt;:ComradeBase.AbstractModel"><code>ComradeBase.intensitymap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intensitymap(model::AbstractModel, dims)</code></pre><p>Computes the intensity map or <em>image</em> of the <code>model</code>. This returns an <code>IntensityMap</code> which is a <code>KeyedArray</code> with <a href="@ref"><code>ImageDimensions</code></a> as keys. The dimensions are a <code>NamedTuple</code> and must have one of the following names:     - (:X, :Y, :T, :F)     - (:X, :Y, :F, :T)     - (:X, :Y) # spatial only where <code>:X,:Y</code> are the RA and DEC spatial dimensions respectively, <code>:T</code> is the the time direction and <code>:F</code> is the frequency direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/images/images.jl#L17-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.ispolarized-Tuple{Type{&lt;:ComradeBase.AbstractModel}}" href="#ComradeBase.ispolarized-Tuple{Type{&lt;:ComradeBase.AbstractModel}}"><code>ComradeBase.ispolarized</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ispolarized(::Type)</code></pre><p>Trait function that defines whether a model is polarized or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/interface.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.isprimitive" href="#ComradeBase.isprimitive"><code>ComradeBase.isprimitive</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isprimitive(::Type)</code></pre><p>Dispatch function that specifies whether a type is a primitive Comrade model. This function is used for dispatch purposes when composing models.</p><p><strong>Notes</strong></p><p>If a user is specifying their own model primitive model outside of Comrade they need to specify if it is primitive</p><pre><code class="language-julia hljs">struct MyPrimitiveModel end
ComradeBase.isprimitive(::Type{MyModel}) = ComradeBase.IsPrimitive()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/interface.jl#L91-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.linearpol-Tuple{StokesParams}" href="#ComradeBase.linearpol-Tuple{StokesParams}"><code>ComradeBase.linearpol</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">linearpol(s)
</code></pre><p>Computes <code>linearpol</code> from a set of stokes parameters <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/polarizedtypes.jl#L446-L450">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.m̆-Union{Tuple{StokesParams{T}}, Tuple{T}} where T" href="#ComradeBase.m̆-Union{Tuple{StokesParams{T}}, Tuple{T}} where T"><code>ComradeBase.m̆</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">m̆(m)
</code></pre><p>Compute the fractional linear polarization of a stokes vector or coherency matrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/polarizedtypes.jl#L455-L459">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.named_dims-Union{Tuple{ComradeBase.AbstractDims{N}}, Tuple{N}} where N" href="#ComradeBase.named_dims-Union{Tuple{ComradeBase.AbstractDims{N}}, Tuple{N}} where N"><code>ComradeBase.named_dims</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">named_dims(g::AbstractDims)</code></pre><p>Returns a named tuple containing the dimensions of <code>g</code>. For a unnamed version see <a href="#ComradeBase.dims-Tuple{ComradeBase.AbstractDims}"><code>dims</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/images/keyed_image.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.phasecenter-Tuple{IntensityMapTypes}" href="#ComradeBase.phasecenter-Tuple{IntensityMapTypes}"><code>ComradeBase.phasecenter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phasecenter(img::IntensityMap)
phasecenter(img::StokesIntensitymap)</code></pre><p>Computes the phase center of an intensity map. Note this is the pixels that is in the middle of the image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/images/methods.jl#L12-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.pixelsizes-Tuple{IntensityMapTypes}" href="#ComradeBase.pixelsizes-Tuple{IntensityMapTypes}"><code>ComradeBase.pixelsizes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pixelsizes(img::IntensityMap)
pixelsizes(img::IntensityMapTypes)</code></pre><p>Returns a named tuple with the spatial pixel sizes of the image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/images/methods.jl#L65-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.radialextent" href="#ComradeBase.radialextent"><code>ComradeBase.radialextent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">radialextent(model::AbstractModel)</code></pre><p>Provides an estimate of the radial size/extent of the <code>model</code>. This is used internally to estimate image size when plotting and using <code>modelimage</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/interface.jl#L214-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.second_moment-Union{Tuple{IntensityMapTypes{T, 2}}, Tuple{T}} where T" href="#ComradeBase.second_moment-Union{Tuple{IntensityMapTypes{T, 2}}, Tuple{T}} where T"><code>ComradeBase.second_moment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">second_moment(im::AbstractIntensityMap; center=true)</code></pre><p>Computes the image second moment tensor of the image. By default we really return the second <strong>cumulant</strong> or centered second moment, which is specified by the <code>center</code> argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/images/methods.jl#L127-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.second_moment-Union{Tuple{IntensityMapTypes{T, N}}, Tuple{N}, Tuple{T}} where {T, N}" href="#ComradeBase.second_moment-Union{Tuple{IntensityMapTypes{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><code>ComradeBase.second_moment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centroid(im::AbstractIntensityMap)</code></pre><p>Computes the image centroid aka the center of light of the image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/images/methods.jl#L117-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.stokes-Tuple{ComradeBase.AbstractPolarizedModel, Symbol}" href="#ComradeBase.stokes-Tuple{ComradeBase.AbstractPolarizedModel, Symbol}"><code>ComradeBase.stokes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stokes(m::AbstractPolarizedModel, p::Symbol)</code></pre><p>Extract the specific stokes component <code>p</code> from the polarized model <code>m</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/interface.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.visanalytic-Tuple{Type{&lt;:ComradeBase.AbstractModel}}" href="#ComradeBase.visanalytic-Tuple{Type{&lt;:ComradeBase.AbstractModel}}"><code>ComradeBase.visanalytic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">visanalytic(::Type{&lt;:AbstractModel})</code></pre><p>Determines whether the model is pointwise analytic in Fourier domain, i.e. we can evaluate its fourier transform at an arbritrary point.</p><p>If <code>IsAnalytic()</code> then it will try to call <code>visibility_point</code> to calculate the complex visibilities. Otherwise it fallback to using the FFT that works for all models that can compute an image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/interface.jl#L145-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.visibility_point" href="#ComradeBase.visibility_point"><code>ComradeBase.visibility_point</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">visibility_point(model::AbstractModel, p)</code></pre><p>Function that computes the pointwise visibility. This must be implemented in the model interface if <code>visanalytic(::Type{MyModel}) == IsAnalytic()</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/7bb206c34d1194749c1d6202cef83d6c6aad3480/src/interface.jl#L180-L185">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Monday 13 February 2023 20:03">Monday 13 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
