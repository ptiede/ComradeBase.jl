var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = ComradeBase","category":"page"},{"location":"#ComradeBase","page":"Home","title":"ComradeBase","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ComradeBase.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [ComradeBase]","category":"page"},{"location":"#ComradeBase.AbstractModel","page":"Home","title":"ComradeBase.AbstractModel","text":"AbstractModel\n\nThe Comrade abstract model type. To instantiate your own model type you should subtybe from this model. Additionally you need to implement the following methods to satify the interface:\n\nMandatory Methods\n\nisprimitive: defines whether a model is standalone or is defined in terms of other models.  is the model is primitive then this should return IsPrimitive() otherwise it returns  NotPrimitive()\nvisanalytic: defines whether the model visibilities can be computed analytically. If yes  then this should return IsAnalytic() and the user must to define visibility_point.  If not analytic then visanalytic should return NotAnalytic().\nimanalytic: defines whether the model intensities can be computed pointwise. If yes\n\nthen this should return IsAnalytic() and the user must to define intensity_point. If not analytic then imanalytic should return NotAnalytic().\n\nradialextent: Provides a estimate of the radial extent of the model in the image domain.  This is used for estimating the size of the image, and for plotting.\nflux: Returns the total flux of the model.\n\nOptional Methods:\n\nintensity_point: Defines how to compute model intensities pointwise. Note this is must be defined if imanalytic(::Type{YourModel})==IsAnalytic().\nvisibility_point: Defines how to compute model visibilties pointwise. Note this is   must be defined if visanalytic(::Type{YourModel})==IsAnalytic().\n_visibilities: Vectorized version of visibility_point if you can gain additional speed\nintensitymap: Computes the whole image of the model\nintensitymap!: Inplace version of intensitymap\n\n\n\n\n\n","category":"type"},{"location":"#ComradeBase.AbstractPolarizedModel","page":"Home","title":"ComradeBase.AbstractPolarizedModel","text":"abstract type AbstractPolarizedModel <: ComradeBase.AbstractModel\n\nType the classifies a model as being intrinsically polarized. This means that any call to visibility must return a StokesParams to denote the full stokes polarization of the model.\n\n\n\n\n\n","category":"type"},{"location":"#ComradeBase.CirBasis","page":"Home","title":"ComradeBase.CirBasis","text":"CirBasis <: PolBasis\n\nMeasurement uses the circular polarization basis, which is typically used for circular feed interferometers.\n\n\n\n\n\n","category":"type"},{"location":"#ComradeBase.CoherencyMatrix","page":"Home","title":"ComradeBase.CoherencyMatrix","text":"CoherencyMatrix(s::StokesParams, basis1::PolBasis)\nCoherencyMatrix(s::StokesParams, basis1::PolBasis, basis2::PolBasis)\nCoherencyMatrix(s::StokesParams, basis1::PolBasis, basis2::PolBasis, refbasis=CirBasis())\n\nConstructs the coherency matrix from the set of stokes parameters s. This is specialized on basis1 and basis2 which form the tensor product basis |basis1><basis2|, or if a single basis is given then by |basis><basis|.\n\nFor example\n\nCoherencyMatrix(s, CircBasis())\n\nwill give the coherency matrix\n\n|I+V   Q+iU|    |Q-iU  I-V |\n\nwhile\n\nCoherencyMatrix(s, LinBasis())\n\nwill give     |I+Q   U+iV|     |U-iV  I-Q |\n\nNotes\n\nInternally this function first converts to a reference basis and then the final basis. You can select the reference basis used with the optional argument refbasis. By default we use the circular basis as our reference. Note that this is only important for mixed bases, e.g., if basis1 and basis2 are different. If basis1==basis2 then the reference basis is never used.\n\n\n\n\n\n","category":"type"},{"location":"#ComradeBase.CoherencyMatrix-2","page":"Home","title":"ComradeBase.CoherencyMatrix","text":"struct CoherencyMatrix{B1, B2, T} <: StaticArraysCore.FieldMatrix{2, 2, T}\n\nCoherency matrix for a single baseline with bases B1 and B2. The two bases correspond to the type of feeds used for each telescope and should be subtypes of PolBasis. To see which bases are implemented type subtypes(Rimes.PolBasis) in the REPL.\n\nFor a circular basis the layout of the coherency matrix is\n\nRR* RL*\nLR* RR*\n\nwhich can be constructed using\n\nc = CoherencyMatrix(RR, LR, RL, LL, CirBasis())\n\nFor a linear basis the layout of the coherency matrix is\n\nXX* XY*\nYX* YY*\n\nwhich can be constructed using\n\nc = CoherencyMatrix(XX, YX, XY, YY, CirBasis())\n\nFor a mixed (e.g., circular and linear basis) the layout of the coherency matrix is\n\nRX* RY*\nLX* LY*\n\nor e.g., linear and circular the layout of the coherency matrix is\n\nXR* XL*\nYR* YL*\n\nThese coherency matrices can be constructed using:\n\n# Circular and linear feeds i.e., |R><X|\nc = CoherencyMatrix(RX, LX, RY, LY, LinBasis(), CirBasis())\n# Linear and circular feeds i.e., |X><R|\nc = CoherencyMatrix(XR, YR, XL, YL, LinBasis(), CirBasis())\n\n\n\n\n\n","category":"type"},{"location":"#ComradeBase.CoherencyMatrix-Tuple{Number, Number, Number, Number, PolBasis, PolBasis}","page":"Home","title":"ComradeBase.CoherencyMatrix","text":"CoherencyMatrix(e11, e21, e12, e22, basis1::PolBasis basis2::PolBasis)\n\nConstructs the coherency matrix with components    e11 e12    e21 e22 relative to the tensor product basis, basis given by |basis1><basis2|.\n\nFor instance\n\nc = Coherency(1.0, 0.0, 0.0, 1.0, CirBasis(), LinBasis())\n\nelements correspond to     RX* RY*     LX* LY*\n\n\n\n\n\n","category":"method"},{"location":"#ComradeBase.CoherencyMatrix-Tuple{Number, Number, Number, Number, PolBasis}","page":"Home","title":"ComradeBase.CoherencyMatrix","text":"CoherencyMatrix(e11, e21, e12, e22, basis::PolBasis)\n\nConstructs the coherency matrix with components    e11 e12    e21 e22 relative to the tensor product basis, basis given by |basis><basis|.\n\nFor instance\n\nc = Coherency(1.0, 0.0, 0.0, 1.0, CirBasis())\n\nelements correspond to     RR* RL*     LR* LL*\n\n\n\n\n\n","category":"method"},{"location":"#ComradeBase.CoherencyMatrix-Tuple{Number, Number, Number, Number, Tuple{PolBasis, PolBasis}}","page":"Home","title":"ComradeBase.CoherencyMatrix","text":"CoherencyMatrix(e11, e21, e12, e22, basis::NTuple{2, PolBasis})\n\nConstructs the coherency matrix with components    e11 e12    e21 e22 relative to the tensor product basis, |basis[1]><basis[2]|. Note that basis[1] and basis[2] could be different.\n\nFor instance\n\nc = Coherency(1.0, 0.0, 0.0, 1.0, CirBasis(), LinBasis())\n\nelements correspond to     RX* RY*     LX* LY*\n\n\n\n\n\n","category":"method"},{"location":"#ComradeBase.DensityAnalytic","page":"Home","title":"ComradeBase.DensityAnalytic","text":"DensityAnalytic\n\nInternal type for specifying the nature of the model functions. Whether they can be easily evaluated pointwise analytic. This is an internal type that may change.\n\n\n\n\n\n","category":"type"},{"location":"#ComradeBase.ElectricFieldBasis","page":"Home","title":"ComradeBase.ElectricFieldBasis","text":"abstract type ElectricFieldBasis\n\nAn abstract type whose subtypes denote a specific electric field basis.\n\n\n\n\n\n","category":"type"},{"location":"#ComradeBase.GriddedKeys","page":"Home","title":"ComradeBase.GriddedKeys","text":"struct GriddedKeys{N, G, Hd, T} <: ComradeBase.AbstractDims{N, T}\n\nThis struct holds the dimensions that the EHT expect. The first type parameter N defines the names of each dimension. These names are usually one of     - (:X, :Y, :T, :F)     - (:X, :Y, :F, :T)     - (:X, :Y) # spatial only where :X,:Y are the RA and DEC spatial dimensions respectively, :T is the the time direction and :F is the frequency direction.\n\nFieldnames\n\ndims\nheader\n\nNotes\n\nWarning it is rare you need to access this constructor directly. Instead use the direct IntensityMap function.\n\n\n\n\n\n","category":"type"},{"location":"#ComradeBase.GriddedKeys-Union{Tuple{NamedTuple{N}}, Tuple{N}, Tuple{NamedTuple{N}, Any}} where N","page":"Home","title":"ComradeBase.GriddedKeys","text":"GriddedKeys(dims::NamedTuple{Na}, header=nothing)\n\nBuilds the EHT image dimensions using the names Na and dimensions are the values of dims. You can also optionally has a header that stores additional information from e.g., a FITS header. The type parameter Na defines the names of each dimension. These names are usually one of     - (:X, :Y, :T, :F)     - (:X, :Y, :F, :T)     - (:X, :Y) # spatial only where :X,:Y are the RA and DEC spatial dimensions respectively, :T is the the time direction and :F is the frequency direction.\n\nNotes\n\nInstead use the direct IntensityMap function.\n\ndims = GriddedKeys((X=-5.0:0.1:5.0, Y=-4.0:0.1:4.0, T=[1.0, 1.5, 1.75], F=[230, 345]))\n\n\n\n\n\n","category":"method"},{"location":"#ComradeBase.GriddedKeys-Union{Tuple{Tuple}, Tuple{Na}, Tuple{Tuple, Any}} where Na","page":"Home","title":"ComradeBase.GriddedKeys","text":"GriddedKeys{Na}(dims::Tuple, header=nothing) where {Na}\n\nBuilds the EHT image dimensions using the names Na and dimensions dims. You can also optionally has a header that stores additional information from e.g., a FITS header. The type parameter Na defines the names of each dimension. These names are usually one of     - (:X, :Y, :T, :F)     - (:X, :Y, :F, :T)     - (:X, :Y) # spatial only where :X,:Y are the RA and DEC spatial dimensions respectively, :T is the the time direction and :F is the frequency direction.\n\nNotes\n\nInstead use the direct IntensityMap function.\n\ndims = GriddedKeys{(:X, :Y, :T, :F)}((-5.0:0.1:5.0, -4.0:0.1:4.0, [1.0, 1.5, 1.75], [230, 345]))\n\n\n\n\n\n","category":"method"},{"location":"#ComradeBase.IntensityMap-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, ComradeBase.AbstractDims}} where {T, N}","page":"Home","title":"ComradeBase.IntensityMap","text":"IntensityMap(data::AbstractArray, dims::NamedTuple)\nIntensityMap(data::AbstractArray, grid::AbstractDims)\n\nConstructs an intensitymap using the image dimensions given by dims. This returns a KeyedArray with keys given by an ImageDimensions object.\n\ndims = (X=range(-10.0, 10.0, length=100), Y = range(-10.0, 10.0, length=100),\n        T = [0.1, 0.2, 0.5, 0.9, 1.0], F = [230e9, 345e9]\n        )\nimgk = IntensityMap(rand(100,100,5,1), dims)\n\n\n\n\n\n","category":"method"},{"location":"#ComradeBase.IsAnalytic","page":"Home","title":"ComradeBase.IsAnalytic","text":"struct IsAnalytic <: ComradeBase.DensityAnalytic\n\nDefines a trait that a states that a model is analytic. This is usually used with an abstract model where we use it to specify whether a model has a analytic fourier transform and/or image.\n\n\n\n\n\n","category":"type"},{"location":"#ComradeBase.IsPrimitive","page":"Home","title":"ComradeBase.IsPrimitive","text":"struct IsPrimitive\n\nTrait for primitive model\n\n\n\n\n\n","category":"type"},{"location":"#ComradeBase.LPol","page":"Home","title":"ComradeBase.LPol","text":"struct LPol <: ComradeBase.ElectricFieldBasis\n\nThe left circular electric field basis, i.e. a left-handed circular feed.\n\n\n\n\n\n","category":"type"},{"location":"#ComradeBase.LinBasis","page":"Home","title":"ComradeBase.LinBasis","text":"LinBasis <: PolBasis\n\nMeasurement uses the linear polarization basis, which is typically used for linear feed interferometers.\n\n\n\n\n\n","category":"type"},{"location":"#ComradeBase.NotAnalytic","page":"Home","title":"ComradeBase.NotAnalytic","text":"struct NotAnalytic <: ComradeBase.DensityAnalytic\n\nDefines a trait that a states that a model is analytic. This is usually used with an abstract model where we use it to specify whether a model has does not have a easy analytic fourier transform and/or intensity function.\n\n\n\n\n\n","category":"type"},{"location":"#ComradeBase.NotPrimitive","page":"Home","title":"ComradeBase.NotPrimitive","text":"struct NotPrimitive\n\nTrait for not-primitive model\n\n\n\n\n\n","category":"type"},{"location":"#ComradeBase.PolBasis","page":"Home","title":"ComradeBase.PolBasis","text":"struct PolBasis{B1<:Union{Missing, ComradeBase.ElectricFieldBasis}, B2<:Union{Missing, ComradeBase.ElectricFieldBasis}}\n\nDenotes a general polarization basis, with basis vectors (B1,B2) which are typically <: Union{ElectricFieldBasis, Missing}\n\n\n\n\n\n","category":"type"},{"location":"#ComradeBase.PrimitiveTrait","page":"Home","title":"ComradeBase.PrimitiveTrait","text":"abstract type PrimitiveTrait\n\nThis trait specifies whether the model is a primitive\n\nNotes\n\nThis will likely turn into a trait in the future so people can inject their models into Comrade more easily.\n\n\n\n\n\n","category":"type"},{"location":"#ComradeBase.RPol","page":"Home","title":"ComradeBase.RPol","text":"struct RPol <: ComradeBase.ElectricFieldBasis\n\nThe right circular electric field basis, i.e. a right-handed circular feed.\n\n\n\n\n\n","category":"type"},{"location":"#ComradeBase.SingleStokes","page":"Home","title":"ComradeBase.SingleStokes","text":"struct SingleStokes{M, S} <: ComradeBase.AbstractModel\n\nHelper function that converts a model from something that compute polarized images to just a single stokes parameter. This is useful if you just want to fit a single stokes parameter.\n\n\n\n\n\n","category":"type"},{"location":"#ComradeBase.StokesParams","page":"Home","title":"ComradeBase.StokesParams","text":"struct StokesParams{T} <: StaticArraysCore.FieldVector{4, T}\n\nStatic vector that holds the stokes parameters of a polarized complex visibility\n\nTo convert between a StokesParams and CoherencyMatrix use the convert function\n\nconvert(::CoherencyMatrix, StokesVector(1.0, 0.1, 0.1, 0.4))\n\n\n\n\n\n","category":"type"},{"location":"#ComradeBase.XPol","page":"Home","title":"ComradeBase.XPol","text":"struct XPol <: ComradeBase.ElectricFieldBasis\n\nThe horizontal or X electric feed basis, i.e. the horizontal linear feed.\n\n\n\n\n\n","category":"type"},{"location":"#ComradeBase.YPol","page":"Home","title":"ComradeBase.YPol","text":"struct YPol <: ComradeBase.ElectricFieldBasis\n\nThe vertical or Y electric feed basis, i.e. the vertical linear feed.\n\n\n\n\n\n","category":"type"},{"location":"#ComradeBase.axisdims-Tuple{AxisKeys.KeyedArray{T, N, <:Any, G} where {T, N, G<:ComradeBase.AbstractDims}}","page":"Home","title":"ComradeBase.axisdims","text":"axisdims(img::IntensityMap)\n\nReturns the keys of the IntensityMap as the actual internal AbstractDims object.\n\n\n\n\n\n","category":"method"},{"location":"#ComradeBase.basis_components","page":"Home","title":"ComradeBase.basis_components","text":"basis_components([T=Float64,], e::ElectricFieldBasis, b::PolBasis)\n\nReturns a static vector that contains the components of the electric field basis vector e in terms of the polarization basis b. The first argument is optionally the eltype of the static vector.\n\nExamples\n\njulia> basis_components(Float64, R(), PolBasis{XPol,Y}())\n2-element StaticArraysCore.SVector{2, ComplexF64} with indices SOneTo(2):\n 0.7071067811865475 + 0.0im\n                0.0 - 0.7071067811865475im\n\njulia> basis_components(R(), PolBasis{XPol,Y}())\n2-element StaticArraysCore.SVector{2, ComplexF64} with indices SOneTo(2):\n 0.7071067811865475 + 0.0im\n                0.0 - 0.7071067811865475im\n\n\njulia> basis_components(Float64, X(), PolBasis{XPol,Y}())\n2-element StaticArraysCore.SVector{2, ComplexF64} with indices SOneTo(2):\n 1.0 + 0.0im\n 0.0 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"#ComradeBase.basis_transform","page":"Home","title":"ComradeBase.basis_transform","text":"basis_transform([T=Float64,], b1::PolBasis, b2::PolBasis)\nbasis_transform([T=Float64,], b1::PolBasis=>b2::PolBasis)\n\nProduces the transformation matrix that transforms the vector components from basis b1 to basis b2. This means that if for example E is the circular basis then basis_transform(CirBasis=>LinBasis)E is in the linear basis. In other words the columns of the transformation matrix are the coordinate vectors of the new basis vectors in the old basis.\n\nExample\n\njulia> basis_transform(CirBasis()=>LinBasis())\n2×2 StaticArraysCore.SMatrix{2, 2, ComplexF64, 4} with indices SOneTo(2)×SOneTo(2):\n 0.707107-0.0im       0.707107-0.0im\n      0.0-0.707107im       0.0+0.707107im\n\n\n\n\n\n","category":"function"},{"location":"#ComradeBase.centroid-Tuple{IntensityMapTypes}","page":"Home","title":"ComradeBase.centroid","text":"centroid(im::AbstractIntensityMap)\n\nComputes the image centroid aka the center of light of the image.\n\n\n\n\n\n","category":"method"},{"location":"#ComradeBase.evpa-Tuple{StokesParams}","page":"Home","title":"ComradeBase.evpa","text":"evpa(m)\n\n\nCompute the evpa of a stokes vector or cohereny matrix.\n\n\n\n\n\n","category":"method"},{"location":"#ComradeBase.fieldofview-Tuple{IntensityMapTypes}","page":"Home","title":"ComradeBase.fieldofview","text":"fieldofview(img::IntensityMap)\nfieldofview(img::IntensityMapTypes)\n\nReturns a named tuple with the field of view of the image.\n\n\n\n\n\n","category":"method"},{"location":"#ComradeBase.flux-Union{Tuple{IntensityMapTypes{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"Home","title":"ComradeBase.flux","text":"flux(im::IntensityMap)\nflux(img::StokesIntensityMap)\n\nComputes the flux of a intensity map\n\n\n\n\n\n","category":"method"},{"location":"#ComradeBase.imagegrid-Tuple{IntensityMapTypes}","page":"Home","title":"ComradeBase.imagegrid","text":"imagegrid(k::IntensityMap)\n\nReturns the grid the IntensityMap is defined as. Note that this is unallocating since it lazily computes the grid. The grid is an example of a KeyedArray and works similarly. This is useful for broadcasting a model across an abritrary grid.\n\n\n\n\n\n","category":"method"},{"location":"#ComradeBase.imagepixels-Tuple{IntensityMapTypes}","page":"Home","title":"ComradeBase.imagepixels","text":"imagepixels(img::IntensityMap)\nimagepixels(img::IntensityMapTypes)\n\nReturns a named tuple with the image pixels locations X and Y.\n\n\n\n\n\n","category":"method"},{"location":"#ComradeBase.imanalytic-Tuple{Type{<:ComradeBase.AbstractModel}}","page":"Home","title":"ComradeBase.imanalytic","text":"imanalytic(::Type{<:AbstractModel})\n\nDetermines whether the model is pointwise analytic in the image domain, i.e. we can evaluate its intensity at an arbritrary point.\n\nIf IsAnalytic() then it will try to call intensity_point to calculate the intensity.\n\n\n\n\n\n","category":"method"},{"location":"#ComradeBase.innerprod","page":"Home","title":"ComradeBase.innerprod","text":"innerprod(::Type{T}, XPol(), YPol())\n\nComputes the complex inner product of two elements of a complex Hilbert space X and Y where base element of the output is T.\n\n\n\n\n\n","category":"function"},{"location":"#ComradeBase.intensity_point","page":"Home","title":"ComradeBase.intensity_point","text":"intensity_point(model::AbstractModel, p)\n\nFunction that computes the pointwise intensity if the model has the trait in the image domain IsAnalytic(). Otherwise it will use construct the image in visibility space and invert it.\n\n\n\n\n\n","category":"function"},{"location":"#ComradeBase.intensitymap","page":"Home","title":"ComradeBase.intensitymap","text":"intensitymap(s, fovx, fovy, nx, ny, x0=0.0, y0=0.0)\n\nCreates a spatial only IntensityMap intensity map whose pixels in the x, y direction are such that the image has a field of view fovx, fovy, with the number of pixels nx, ny, and the origin or phase center of the image is at x0, y0.\n\n\n\n\n\n","category":"function"},{"location":"#ComradeBase.intensitymap-2","page":"Home","title":"ComradeBase.intensitymap","text":"intensitymap(model::AbstractModel, args...)\n\nComputes the intensity map of model. For the inplace version see intensitymap!\n\n\n\n\n\n","category":"function"},{"location":"#ComradeBase.intensitymap!","page":"Home","title":"ComradeBase.intensitymap!","text":"intensitymap!(buffer::AbstractDimArray, model::AbstractModel)\n\nComputes the intensity map of model by modifying the buffer\n\n\n\n\n\n","category":"function"},{"location":"#ComradeBase.intensitymap!-Union{Tuple{M}, Tuple{IntensityMapTypes, M}} where M","page":"Home","title":"ComradeBase.intensitymap!","text":"intensitymap!(img::AbstractIntensityMap, mode;, executor = SequentialEx())\n\nComputes the intensity map or image of the model. This updates the IntensityMap object img.\n\nOptionally the user can specify the executor that uses FLoops.jl to specify how the loop is done. By default we use the SequentialEx which uses a single-core to construct the image.\n\n\n\n\n\n","category":"method"},{"location":"#ComradeBase.intensitymap-Union{Tuple{M}, Tuple{M, ComradeBase.AbstractDims}} where M<:ComradeBase.AbstractModel","page":"Home","title":"ComradeBase.intensitymap","text":"intensitymap(model::AbstractModel, dims)\n\nComputes the intensity map or image of the model. This returns an IntensityMap which is a KeyedArray with ImageDimensions as keys. The dimensions are a NamedTuple and must have one of the following names:     - (:X, :Y, :T, :F)     - (:X, :Y, :F, :T)     - (:X, :Y) # spatial only where :X,:Y are the RA and DEC spatial dimensions respectively, :T is the the time direction and :F is the frequency direction.\n\n\n\n\n\n","category":"method"},{"location":"#ComradeBase.ispolarized-Tuple{Type{<:ComradeBase.AbstractModel}}","page":"Home","title":"ComradeBase.ispolarized","text":"ispolarized(::Type)\n\nTrait function that defines whether a model is polarized or not.\n\n\n\n\n\n","category":"method"},{"location":"#ComradeBase.isprimitive","page":"Home","title":"ComradeBase.isprimitive","text":"isprimitive(::Type)\n\nDispatch function that specifies whether a type is a primitive Comrade model. This function is used for dispatch purposes when composing models.\n\nNotes\n\nIf a user is specifying their own model primitive model outside of Comrade they need to specify if it is primitive\n\nstruct MyPrimitiveModel end\nComradeBase.isprimitive(::Type{MyModel}) = ComradeBase.IsPrimitive()\n\n\n\n\n\n","category":"function"},{"location":"#ComradeBase.linearpol-Tuple{StokesParams}","page":"Home","title":"ComradeBase.linearpol","text":"linearpol(s)\n\n\nComputes linearpol from a set of stokes parameters s.\n\n\n\n\n\n","category":"method"},{"location":"#ComradeBase.m̆-Union{Tuple{StokesParams{T}}, Tuple{T}} where T","page":"Home","title":"ComradeBase.m̆","text":"m̆(m)\n\n\nCompute the fractional linear polarization of a stokes vector or coherency matrix\n\n\n\n\n\n","category":"method"},{"location":"#ComradeBase.phasecenter-Tuple{IntensityMapTypes}","page":"Home","title":"ComradeBase.phasecenter","text":"phasecenter(img::IntensityMap)\nphasecenter(img::StokesIntensitymap)\n\nComputes the phase center of an intensity map. Note this is the pixels that is in the middle of the image.\n\n\n\n\n\n","category":"method"},{"location":"#ComradeBase.pixelsizes-Tuple{IntensityMapTypes}","page":"Home","title":"ComradeBase.pixelsizes","text":"pixelsizes(img::IntensityMap)\npixelsizes(img::IntensityMapTypes)\n\nReturns a named tuple with the spatial pixel sizes of the image.\n\n\n\n\n\n","category":"method"},{"location":"#ComradeBase.radialextent","page":"Home","title":"ComradeBase.radialextent","text":"radialextent(model::AbstractModel)\n\nProvides an estimate of the radial size/extent of the model. This is used internally to estimate image size when plotting and using modelimage\n\n\n\n\n\n","category":"function"},{"location":"#ComradeBase.second_moment-Union{Tuple{IntensityMapTypes{T, 2}}, Tuple{T}} where T","page":"Home","title":"ComradeBase.second_moment","text":"second_moment(im::AbstractIntensityMap; center=true)\n\nComputes the image second moment tensor of the image. By default we really return the second cumulant or centered second moment, which is specified by the center argument.\n\n\n\n\n\n","category":"method"},{"location":"#ComradeBase.second_moment-Union{Tuple{IntensityMapTypes{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"Home","title":"ComradeBase.second_moment","text":"centroid(im::AbstractIntensityMap)\n\nComputes the image centroid aka the center of light of the image.\n\n\n\n\n\n","category":"method"},{"location":"#ComradeBase.stokes-Tuple{ComradeBase.AbstractPolarizedModel, Symbol}","page":"Home","title":"ComradeBase.stokes","text":"stokes(m::AbstractPolarizedModel, p::Symbol)\n\nExtract the specific stokes component p from the polarized model m\n\n\n\n\n\n","category":"method"},{"location":"#ComradeBase.visanalytic-Tuple{Type{<:ComradeBase.AbstractModel}}","page":"Home","title":"ComradeBase.visanalytic","text":"visanalytic(::Type{<:AbstractModel})\n\nDetermines whether the model is pointwise analytic in Fourier domain, i.e. we can evaluate its fourier transform at an arbritrary point.\n\nIf IsAnalytic() then it will try to call visibility_point to calculate the complex visibilities. Otherwise it fallback to using the FFT that works for all models that can compute an image.\n\n\n\n\n\n","category":"method"},{"location":"#ComradeBase.visibility_point","page":"Home","title":"ComradeBase.visibility_point","text":"visibility_point(model::AbstractModel, p)\n\nFunction that computes the pointwise visibility. This must be implemented in the model interface if visanalytic(::Type{MyModel}) == IsAnalytic()\n\n\n\n\n\n","category":"function"}]
}
